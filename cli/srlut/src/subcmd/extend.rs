use std::{fs::File, io::BufReader, path::PathBuf};

use clap::Args;
use sanctum_solana_cli_utils::{parse_signer, HandleTxArgs, TxSendingNonblockingRpcClient};
use solana_sdk::{
    address_lookup_table::{instruction::extend_lookup_table, state::AddressLookupTable},
    compute_budget::ComputeBudgetInstruction,
    message::{v0::Message, VersionedMessage},
    pubkey::Pubkey,
    transaction::VersionedTransaction,
};

use crate::lut_list::LutList;

use super::Subcmd;

mod srlut {
    sanctum_macros::declare_program_keys!("KtrvWWkPkhSWM9VMqafZhgnTuozQiHzrBDT8oPcMj3T", []);
}

const MAX_ACCOUNTS_PER_LUT_EXTEND: usize = 29;

#[derive(Args, Debug)]
#[clap(long_about = "Extend the LUT with the accounts on a generated json pubkey list")]
pub struct ExtendArgs {
    #[clap(
        long,
        short,
        default_value = "./keys.json",
        help = "Path of input json file generated by gen cmd."
    )]
    pub input: PathBuf,

    #[clap(
        long,
        short,
        help = "The LUT's admin. Defaults to config wallet if not set."
    )]
    pub auth: Option<String>,

    #[clap(
        long,
        short,
        default_value_t = srlut::ID,
        help = "The LUT address."
    )]
    pub lut: Pubkey,
}

impl ExtendArgs {
    pub async fn run(args: crate::Args) {
        let Self {
            input,
            auth,
            lut: lut_addr,
        } = match args.subcmd {
            Subcmd::Extend(a) => a,
            _ => unreachable!(),
        };

        let payer = args.config.signer();
        let rpc = args.config.nonblocking_rpc_client();

        let auth_signer = auth.map(|s| parse_signer(&s).unwrap());
        let auth = auth_signer.as_ref().unwrap_or(&payer);

        let file = File::open(&input).unwrap();
        let LutList(mut lut_list) = serde_json::from_reader(BufReader::new(file)).unwrap();

        let lut_acc_data = rpc.get_account_data(&lut_addr).await.unwrap();
        let lut = AddressLookupTable::deserialize(&lut_acc_data).unwrap();

        lut_list.retain(|addr| !lut.addresses.contains(addr));
        lut_list.sort();
        lut_list.dedup();

        if lut_list.is_empty() {
            eprintln!("LUT already synced, nothing to be done");
            return;
        }

        let mut signers = vec![payer.as_ref(), auth.as_ref()];
        signers.dedup();

        for chunk in lut_list.chunks(MAX_ACCOUNTS_PER_LUT_EXTEND) {
            let ix = extend_lookup_table(
                lut_addr,
                auth.pubkey(),
                Some(payer.pubkey()),
                chunk.to_vec(),
            );
            let rbh = rpc.get_latest_blockhash().await.unwrap();
            let tx = VersionedTransaction::try_new(
                VersionedMessage::V0(
                    Message::try_compile(
                        &payer.pubkey(),
                        &[
                            // hardcode CUs to set to 5k lamports prio fees for now.
                            // simulation shows extend lut always takes 600 CUs + 600 CUs for CU ixs = 1200 CUs
                            ComputeBudgetInstruction::set_compute_unit_limit(1_500),
                            ComputeBudgetInstruction::set_compute_unit_price(3_333_334),
                            ix,
                        ],
                        &[],
                        rbh,
                    )
                    .unwrap(),
                ),
                &signers,
            )
            .unwrap();
            rpc.handle_tx(&tx, args.send_mode, HandleTxArgs::default())
                .await;
        }
    }
}
